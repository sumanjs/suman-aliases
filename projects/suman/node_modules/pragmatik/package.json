{
  "_args": [
    [
      {
        "raw": "pragmatik@latest",
        "scope": null,
        "escapedName": "pragmatik",
        "name": "pragmatik",
        "rawSpec": "latest",
        "spec": "latest",
        "type": "tag"
      },
      "/Users/alexamil/WebstormProjects/oresoftware/sumanjs/suman-aliases/projects/suman/node_modules/suman"
    ]
  ],
  "_from": "pragmatik@latest",
  "_id": "pragmatik@0.0.410",
  "_inCache": true,
  "_location": "/pragmatik",
  "_nodeVersion": "6.10.2",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/pragmatik-0.0.410.tgz_1512701596007_0.559150266693905"
  },
  "_npmUser": {
    "name": "oresoftware",
    "email": "alex@oresoftware.com"
  },
  "_npmVersion": "4.6.1",
  "_phantomChildren": {
    "color-convert": "1.9.1",
    "escape-string-regexp": "1.0.5",
    "has-flag": "2.0.0"
  },
  "_requested": {
    "raw": "pragmatik@latest",
    "scope": null,
    "escapedName": "pragmatik",
    "name": "pragmatik",
    "rawSpec": "latest",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "/suman"
  ],
  "_resolved": "https://registry.npmjs.org/pragmatik/-/pragmatik-0.0.410.tgz",
  "_shasum": "07e52c66a3f526321a47339c3a97806d3df9a2c7",
  "_shrinkwrap": null,
  "_spec": "pragmatik@latest",
  "_where": "/Users/alexamil/WebstormProjects/oresoftware/sumanjs/suman-aliases/projects/suman/node_modules/suman",
  "author": {
    "name": "Olegzandr Denman"
  },
  "dependencies": {
    "chalk": "^2.3.0",
    "log-prepend": "latest"
  },
  "description": "Parse arguments correctly for variadic functions",
  "devDependencies": {
    "@types/async": "^2.0.38",
    "@types/core-js": "^0.9.35",
    "@types/lodash": "^4.14.50",
    "@types/node": "^7.0.0",
    "node-check-fast": "latest"
  },
  "directories": {},
  "dist": {
    "shasum": "07e52c66a3f526321a47339c3a97806d3df9a2c7",
    "tarball": "https://registry.npmjs.org/pragmatik/-/pragmatik-0.0.410.tgz"
  },
  "gitHead": "1d3f04258bf71ace9dc5ca7a5d772b449bfa7af7",
  "keywords": [
    "arguments",
    "variadic",
    "varargs",
    "nodejs",
    "dynamic"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "oresoftware",
      "email": "alex@oresoftware.com"
    }
  ],
  "name": "pragmatik",
  "optionalDependencies": {},
  "readme": "\n# Pragmatik\n\nThis library attempts to solve an age-old problem in JavaScript => how do we correctly parse the arguments inside a function\nthat accepts a variable number of arguments? (See \"variadic functions\" and \"varargs\"). \n\nThis library allows you to elegantly parse arguments at runtime and assign them to the \ncorrect/expected variable in the function signature, according to the parsing rules you define.\nIt is most useful for public and private APIs where we want to give our users the convenience of omitting variables,\nand not requiring them to pass ```null``` or other placeholder values. Of course, you should design your APIs well,\nwith simple function calls with limited number of variation in the signature. Using options objects is a great\ndesign pattern to keep things simple, but at some point variadic functions become convenient and we must handle \nthem well, without writing buggy code that will fail silently in edge cases.\n\n\n### Disclaimer => the Pragmatik library is in beta\n\nI have seen so many people roll their own solution to this problem - I would be willing to bet at least 1000 JS libraries have public APIs that accept\nvariable number of arguments and/or optional arguments. \nAt best we get bad error messages or no error messages. At worst, we end up with runtimes using the \nwrong values, until something breaks, or worse until something succeeds. Pragmatik is designed to fail-fast => \n(1) if your function parsing rules are not valid, an error is thrown (2) if any function cannot be parsed successfully given the runtime arguments and the parsing rules, \nan error is thrown.\n\nExtensive testing needs to be completed before this library is totally proven. Also need some sanity checks to make sure this is exactly what people\nneed and want. We will incorporate other \"types\" that can be easily and reliably checked, like 'array'. \nUnfortunately, type checking beyond simple primitive types is not an effective strategy because you don't know whether the user passed \nin the argument in the wrong place in the signature or if they passed the wrong value for the right argument.\n\n## Basic Usage\n\nThe Pragmatik library exports two functions: ```parse``` and ```signature```\n\nThe following is a function that accepts varargs, and we use Pragmatik to parse the arguments:\n\n```js\nconst pragmatik = require('pragmatik');\n\nfunction foo(){\n const [a,b,c,d,e] = pragmatik.parse(arguments, rules);\n  \n}\n```\n\nso we can call foo above, like so:\n\n```foo(true, {zim:'zam'}, function(){});```\n\nand Pragmatik can be used to parse the values as they are expected to appear, for example, first we\nuse signature() to define the parsing rules:\n\n```js\nconst pragmatik = require('pragmatik');\n\nconst r = pragmatik.signature({\n\n    mode: 'strict',                        // does not allow two adjacent non-required types to be the same\n    allowExtraneousTrailingVars: false,    // no more than 5 arguments allowed\n    args: [\n      {\n        type: 'string',\n        required: false,\n      },\n      {\n        type: 'boolean',\n        required: true,\n      },\n      {\n        type: 'object',\n        required: true,\n      },\n      {\n        type: 'boolean',\n        required: false,\n      },\n      {\n        type: 'function',\n        required: false,\n      }\n    ]\n });\n\n\nfunction foo(){\n const [a,b,c,d,e] = pragmatik.parse(arguments, rules);\n \n console.log(a,b,c,d,e); \n // a => undefined\n // b => true\n // c => {zim:'zam'}\n // d => undefined\n // e => function(){}\n \n}\n```\n\nif you want better better IDE support, you can do the following instead, but it's fairly unnecessary, (especially\nconsidering the purpose of the library is to support varargs):\n\n```js\nfunction foo(a,b,c,d,e){\n var [a,b,c,d,e] = pragmatik.parse(arguments, rules);\n  \n}\n```\n\n\n\n# Motivation\n\nAs JS is a dynamic language, we can omit arguments completely and still call functions.\n\nFor example,\n\n```js\nfunction foo(a,b,c){\n\n}\n```\n\nwe can call foo without any arguments at all:\n\n```js\nfoo();\n```\n\nand this is valid, of course. But in statically typed languages, this probably won't even compile, let alone run :)\n\nSo, what if argument a is \"optional\", but b and c are \"required\"?\n\nfoo might look like:\n\n```js\nfunction foo(a,b,c){\n  a = a || 'temp';\n  // yadda yadda\n  console.log('a:',a,', b:',b,', c:',c);\n}\n```\n\nif we call foo like this:\n\n```js\nfoo('this is b', 'this is c');\n```\n\nthen of course, we will get:\n\n```a: this is b , b: this is c , c: undefined```\n\nWhich is totally incorrect, according to our intentions. And the problem only gets\nworse in more complicated function calls.\n\nWe could solve this, by requiring users to always pass 3 arguments, no more, no less, which would be:\n\n```js\nfoo(null, 'this is b', 'this is c');\n```\n\nBut what if we want to make our APIs as beautiful as possible and give our users the convenience of omitting\nvariables?\n\n**Enter pragmatik.**\n\n\n\n## Advanced usage\n\n\nPragmatik first validates your rules object, to make sure the rules you define are valid according to the way\nthis library works. Parsing varargs is more difficult than you might think, and you have to settle \non a good strategy.\n\nPragmatik uses types ('function','object','string') as a building block for determining if you passed in the \nexpected variable at the given argument index.",
  "readmeFilename": "README.md",
  "scripts": {
    "test": "./scripts/test.sh"
  },
  "version": "0.0.410"
}
